from fastapi import APIRouter, HTTPException, Depends, Request
from sqlalchemy.orm import Session
from app.database import get_db
from app.models.orchestrator import JarvisScanReport
from app.models.cases_sql import CaseORM
import httpx
import os
import logging
import json

router = APIRouter()
logger = logging.getLogger(__name__)

VULN_SERVICE_URL = os.getenv("VULN_SERVICE_URL", "http://vuln_service:8083")

@router.post("/scan-completed")
async def handle_scan_completed(request: Request, db: Session = Depends(get_db)):
    """
    Webhook received from Vuln Service when a scan finishes.
    """
    payload = await request.json()
    scan_id = payload.get("scan_id")
    status = payload.get("status")
    target = payload.get("target")
    
    logger.info(f"Webhook received for scan {scan_id} (Status: {status})")
    
    if status != "completed":
        return {"status": "ignored", "reason": "scan not completed"}
    
    # 1. Fetch Findings
    async with httpx.AsyncClient() as client:
        try:
            resp = await client.get(f"{VULN_SERVICE_URL}/vuln/findings/{scan_id}")
            findings = resp.json()
        except Exception as e:
            logger.error(f"Failed to fetch findings: {e}")
            return {"status": "error", "detail": "failed to fetch findings"}

    # 2. Generate AI Report (Mocked for now, or simple logic)
    # In a real scenario, we would send 'findings' to Ollama/LLM.
    
    severity_counts = {"critical": 0, "high": 0, "medium": 0, "low": 0, "info": 0}
    high_risk_findings = []
    
    for f in findings:
        sev = f.get("severity", "info").lower()
        if sev in severity_counts:
            severity_counts[sev] += 1
        
        if sev in ["critical", "high", "medium"]:
            high_risk_findings.append(f"{f.get('name')} ({sev})")

    ai_summary = f"""# Reporte de Seguridad IA
**Target:** {target}
**Fecha:** {payload.get('end_time', 'N/A')}

## Resumen Ejecutivo
Se ha completado el escaneo de vulnerabilidades. Se detectaron **{len(findings)}** hallazgos en total.

### Perfil de Riesgo
* Críticas: {severity_counts['critical']}
* Altas: {severity_counts['high']}
* Medias: {severity_counts['medium']}

## Hallazgos Destacados
{chr(10).join(['- ' + h for h in high_risk_findings]) if high_risk_findings else "No se detectaron vulnerabilidades de alto riesgo."}

## Recomendaciones
Se recomienda revisar los hallazgos críticos y aplicar los parches correspondientes.
"""

    # 3. Update Report
    report = db.query(JarvisScanReport).filter(JarvisScanReport.scan_id == scan_id).first()
    if not report:
        # Fallback if not created (should not happen if flow is correct)
        report = JarvisScanReport(
            scan_id=scan_id,
            resumen_tecnico=ai_summary,
            riesgos_principales=severity_counts,
            recomendaciones={"note": "Generated by Jarvis AI"}
        )
        db.add(report)
    else:
        report.resumen_tecnico = ai_summary
        report.riesgos_principales = severity_counts
        report.recomendaciones = {"note": "Generated by Jarvis AI"}
    
    # 4. Create Case if High/Critical
    if severity_counts["critical"] > 0 or severity_counts["high"] > 0:
        new_case = CaseORM(
            title=f"Vulnerabilidades Críticas en {target}",
            description=f"Se detectaron {severity_counts['critical']} críticas y {severity_counts['high']} altas.\n\n{ai_summary}",
            severity="high" if severity_counts["critical"] == 0 else "critical",
            status="open",
            asset_id=report.asset_id,
            client_id=report.client_id
        )
        db.add(new_case)
        logger.info(f"Created Case {new_case.id} for scan {scan_id}")

    db.commit()
    
    return {"status": "processed", "report_id": report.id}
