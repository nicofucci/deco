import asyncio
import logging
from datetime import datetime, timedelta
from sqlalchemy import desc
from app.database import SessionLocal
# Assuming we have a Vulnerability model, if not we might need to query raw SQL or check how vuln_service stores data.
# Based on file list, there is no explicit vuln model in jarvis_api/app/models, but there is `vuln.py` in orchestrator.
# However, the prompt says "Integrate with existing metrics... Pentesting (Vuln Service + Pentest Worker)".
# Since Jarvis API might not have direct access to Vuln Service DB (microservices), we might need to check if Jarvis stores this data.
# Looking at `jarvis_api/app/agents/advanced/vuln_scanner.py` might give a clue.
# If no DB access, we might need to poll the Vuln Service API.
# BUT, the prompt implies we are inside Jarvis API and should use `alerts_service`.
# Let's assume for now we can query the `vuln_service` via HTTP or if there is a shared DB table.
# Given the architecture, `vuln_service` has its own DB.
# However, `jarvis_api` has `app/agents/advanced/vuln_scanner.py`.
# Let's check `vuln_scanner.py` to see where it stores results.
# Wait, `jarvis_api` main.py has `vuln_scanner = VulnScannerAgent(ollama_client)`.
# And `run_vuln_scan` returns results but doesn't seem to save to a local Jarvis DB table (it returns JSON).
# The prompt says "Se detecta una vulnerabilidad CRITICAL".
# This implies we should hook into the scanning process OR poll a source.
# Since this is a "Watcher", polling is expected.
# If `vuln_service` is separate, we should poll it.
# Let's assume we poll `http://vuln_service:8083/api/vulns` (guessing port/path based on docker-compose).
# Docker compose says `vuln_service` is on 8083.

import httpx
from app.services.alerts_service import create_alert_from_event

logger = logging.getLogger(__name__)

VULN_SERVICE_URL = "http://vuln_service:8083"

async def start_pentest_watcher():
    """
    Monitor Pentest Results.
    Runs every 2 minutes.
    """
    logger.info("Starting Pentest Watcher...")
    while True:
        try:
            await check_pentest_results()
        except Exception as e:
            logger.error(f"Error in Pentest Watcher: {e}")
        
        await asyncio.sleep(120)

async def check_pentest_results():
    db = SessionLocal()
    try:
        async with httpx.AsyncClient() as client:
            # Fetch recent vulnerabilities
            # Assuming an endpoint like /api/vulns?limit=50
            try:
                resp = await client.get(f"{VULN_SERVICE_URL}/api/vulns", params={"limit": 50})
                if resp.status_code == 200:
                    vulns = resp.json()
                    for vuln in vulns:
                        # Check if new (simple check by ID or timestamp if possible, but for now just alert on active criticals)
                        # To avoid spam, create_alert_from_event should handle deduplication if status is open.
                        
                        severity = vuln.get("severity", "low").lower()
                        
                        if severity == "critical":
                            create_alert_from_event(
                                db,
                                event_type="PENTEST",
                                severity="critical",
                                source="vuln_service",
                                title=f"Critical Vulnerability: {vuln.get('title')}",
                                description=f"Found critical vulnerability on {vuln.get('target')}: {vuln.get('description')}",
                                metadata=vuln,
                                asset_id=vuln.get("target")
                            )
                        elif severity == "high":
                            create_alert_from_event(
                                db,
                                event_type="PENTEST",
                                severity="high",
                                source="vuln_service",
                                title=f"High Vulnerability: {vuln.get('title')}",
                                description=f"Found high vulnerability on {vuln.get('target')}: {vuln.get('description')}",
                                metadata=vuln,
                                asset_id=vuln.get("target")
                            )
            except httpx.RequestError:
                logger.warning("Vuln Service unreachable")
                # We could alert on this too if needed, but system_health_watcher might cover it.

            # Check Pentest Worker Status
            # Assuming endpoint /health or /status
            try:
                resp = await client.get(f"http://pentest_worker:8082/health")
                if resp.status_code != 200:
                     create_alert_from_event(
                        db,
                        event_type="PENTEST",
                        severity="critical",
                        source="pentest_worker",
                        title="Pentest Worker Error",
                        description=f"Pentest worker returned status {resp.status_code}",
                        metadata={"status_code": resp.status_code}
                    )
            except httpx.RequestError:
                 create_alert_from_event(
                    db,
                    event_type="PENTEST",
                    severity="critical",
                    source="pentest_worker",
                    title="Pentest Worker Unreachable",
                    description="Could not connect to pentest_worker container.",
                    metadata={}
                )

    finally:
        db.close()
